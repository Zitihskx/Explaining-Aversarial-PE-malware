#!/usr/bin/env python
# coding: utf-8

# In[3]:


def grad_attack(test_path, start, end):
    #Import Libraries
    import os
    import time
    import sys
    import yaml
    import numpy as np
    import pandas as pd
    from src.util import ExeDataset, write_pred
    from src.model import MalConv
    from torch.utils.data import DataLoader
    import torch.nn as nn
    import torch.optim as optim
    from torch.autograd import Variable
    import time
    import torch

    debug = True

    config_path = 'config/example.yaml' #needs to modify to point to a new list of valid label
    seed = int(123)
    conf = yaml.load(open(config_path, 'r'), Loader = yaml.SafeLoader)
    
    use_gpu = conf['use_gpu']
    use_cpu = conf['use_cpu']
    exp_name = conf['exp_name'] + '_sd_' + str(seed)
    
    valid_data_path = conf['valid_data_path']
    valid_label_path = conf['valid_label_path']
    
    checkpoint_dir = conf['checkpoint_dir']
    chkpt_acc_path = checkpoint_dir + exp_name + '.model'
    
    malconv = torch.load('checkpoint/example_sd_123.model', map_location=torch.device('cpu'))

    history = {}
    history['val_loss'] = []
    history['val_acc'] = []
    history['val_pred'] = []
    bce_loss = nn.BCEWithLogitsLoss()
    total=0
    evade = 0
    changes=[]
    
    
    with open(test_path,'rb') as f:
        exe_input = [i+1 for i in f.read()]
    length = len(exe_input)
    #exe_input = exe_input.cpu().numpy()
    data = np.concatenate([exe_input, np.random.randint(0, 256, 2000000-length)])
    label = Variable(torch.from_numpy(np.array([[0]])).float(), requires_grad=False)
    embed = malconv.embed
    sigmoid = nn.Sigmoid()
    
    for t in range(10):
        exe_input = torch.from_numpy(np.array([data]))
        exe_input = Variable(exe_input.long(), requires_grad=False)
        pred = malconv(exe_input)
        prob = sigmoid(pred).cpu().data.numpy()[0][0]
        if t==0:
            init_prob = prob
        if prob < 0.5:
            print("prob<0.5,success.")
            return prob
        loss = bce_loss(pred, label)
        loss.backward()
        w = malconv.embed_x.grad[0].data
        z = malconv.embed_x.data[0]

        for j in range(start, end):
            if j % 100 == 0:
                exe_input = torch.from_numpy(np.array([data]))
                exe_input = Variable(exe_input.long(), requires_grad=False)
                pred = malconv(exe_input)
                prob = sigmoid(pred).cpu().data.numpy()[0][0]
                    
                if debug==True:
                    print("prob: ", prob)
                        
                count_j = j
                if prob < 0.5:
                    break
                # if debug == True:
                #     print("changing " + str(j) + "th byte")
            try:
                min_index = -1
                min_di = int(1.15*length)
                wj = -w[j:j + 1, :]
                nj = wj / torch.norm(wj, 2)
                zj = z[j:j + 1, :]
                for i in range(1, 256):
                    mi = embed(Variable(torch.from_numpy(np.array([i])))).data
                    si = torch.matmul((nj), torch.t(mi - zj))
                    di = torch.norm(mi - (zj + si * nj))
                    si = si.cpu().numpy()
                    if si > 0 and di < min_di:
                        min_di = di
                        min_index = i
                if min_index != -1:
                    data[j] = min_index
                    changes.append(min_index)
            except:
                continue
    return prob
        




